{
    "contents" : "---\nlayout: post\ntitle: Working with NetCDF files in R\nsource: rmd\n---\n\n[NetCDF](http://en.wikipedia.org/wiki/NetCDF) is an open file format commonly used to store oceanographic (and other) data such as sea surface temperature (SST), sea level pressure (SLP), and much more. I recently needed to work with SST data from the [NCEP Reanalysis](http://www.esrl.noaa.gov/psd/data/gridded/data.ncep.reanalysis.surface.html) and found that I didn't know how to work with NetCDF files. This post should serve as a short introduction working with NetCDF files using the R package `ncdf`.\n\n## Step 1: Acquire the NetCDF library\n\nBefore we can open a NetCDF file in R, we need to install the NetCDF library on our system. I'm using a Mac running OS 10.9 and I use [`homebrew`](http://brew.sh/) as my package manager. \n\nIf you're using `homebrew`, install the `netcdf` library with:\n\n```{sh}\nbrew install netcdf\n```\n\nIf you're on Windows, you can find pre-built binaries at the developer's [download page](http://www.unidata.ucar.edu/downloads/netcdf/index.jsp). For other systems, consult the [documentation](http://www.unidata.ucar.edu/software/netcdf/docs/getting.html).\n\n## Step 2: Install and load the `ncdf` package in R\n\n```{r eval=FALSE}\ninstall.packages(\"ncdf\")\n```\n\nAnd load it:\n\n```{r}\nlibrary(ncdf)\n```\n\n## Step 3: Load your NetCDF file\n\nFor this tutorial, I'll be working with the [NOAA Optimum Interpolation (OI) Sea Surface Temperature (SST) V2](http://www.esrl.noaa.gov/psd/data/gridded/data.noaa.oisst.v2.html) data series of monthly means from December 1981 -- current. These data are produced on a 1&deg; grid for the entire globe.\n\n```{r}\n# File located at ftp://ftp.cdc.noaa.gov/Datasets/noaa.oisst.v2/sst.mnmean.nc (2014-02-14)\nfilename <- \"~/Documents/Datasets/sst.mnmean.nc\"\ncdf <- open.ncdf(filename)\n```\n\nI am interested in the following variables: latitude, longitude, time, and SST:\n\n```{r}\nlat <- get.var.ncdf(cdf, varid=\"lat\")\nlon <- get.var.ncdf(cdf, varid=\"lon\")\ntime <- get.var.ncdf(cdf, varid=\"time\")\nsst <- get.var.ncdf(cdf, varid=\"sst\")\n```\n\nThe `lat` and `lon` variables are just vectors containing the range of latitudes (89.5S to 89.5N) and longitudes (0.5&deg;E to 359.5&deg;E, starting from the prime meridian).\n\nThe `time` variable is a little more complex. Let's take a look:\n\n```{r}\nhead(time)\n```\n\nThose don't look like times at all. If you're used to working with dates and times on computers, you may already be way ahead of me. If, however, if you are not, I'll explain. Dates and times are usually stored by computers as a number of time units since we started counting time. The time units may be milliseconds, seconds, or even months -- whatever suits the purpose. Computers commonly store dates and times as the number of seconds since January 1, 1970 (See [UNIX time](http://en.wikipedia.org/wiki/Unix_time)). In the case of our data, time is being counted as **days** since January 1, 1800. This is a little weird but it makes sense for our data. If you're using a different NetCDF file than me, you'll want to consult the documentation that goes along with the data to figure out how they're counting time.\n\nNow that we know how `time` is being stored, we can make it human-readable:\n\n```{r}\ntime_d <- as.Date(time, format=\"%j\", origin=as.Date(\"1800-01-01\"))\ntime_years <- format(time_d, \"%Y\")\ntime_months <- format(time_d, \"%m\")\ntime_year_months <- format(time_d, \"%Y-%m\")\n```\n\nHere, I set the origin to January 1, 1800 and then convert the original variable `time` into a vector of R `Date` objects, passing the parameters `format=\"%j\"` and `origin=as.Date(\"1800-01-01\")`. The `time` variable is now much more easier to understand:\n\n```{r}\nhead(time_d)\n```\n\nThe other variables I created, `time_years`, `time_months`, `time_year_months` are for added utility. I can now reference SST data for just a set of years\n\n```{r, eval=F}\ntime_years %in% c(\"1990\", \"1991\")\n```\n\nor all SST values from June\n\n```{r, eval=F}\ntime_months %in% c(\"06\")\n```\n\nOur last, but most important variable is SST.\n\n```{r}\ndim(sst)\n```\n\n`sst` is three dimensional, and is indexed by longitude, latitude, and time (respectively). To extract a single SST value from it, we'll need to specify an index or range of indices for all three dimensions:\n\n```{r}\nsst[lon==220.5, lat==50.5, time_d==as.Date(\"1990-06-01\")]\n```\n\nWe can use our utility variables to, for example, extract all the observations for June from this same grid cell:\n\n```{r}\nsst[lon==220.5, lat==50.5, time_months==\"06\"]\n```\n\nDepending on your goals, this may be as far as you need to get. But maybe you want to display these data visually. Let's plot the SSTs for a range of grid cells onto a map.\n\n## Step 4: Convert the SST data to a `data.frame`\n\nOur NetCDF file has a lot of observations:\n\n```{r}\nprod(dim(sst))\n```\n\nTo reduce the amount of computation, let's subset the data to a range of latitudes and longitudes and also focus in on a particular month in the data set so we can plot this in two dimensions:\n\n```{r}\nlat_range <- seq(55.5, 60.5)\nlon_range <- seq(190.5, 195.5)\n\nlat_indices <- lat %in% lat_range\nlon_indices <- lon %in% lon_range\ntime_indices <- time_year_months==\"1990-06\" # June of 1990\n```\n\nNotice how I constructed the `_indices` variables. They are vectors of the same length as their corresponding variable but they contain TRUEs and FALSEs where the corresponding variable is equal to the desired ranges. This allows instant subsetting:\n\n```{r}\nsst[lon_indices, lat_indices, time_indices]\n```\n\nWhich gives us the SST values for the 5x5 grid for June of 1990. To save them in a more convenient format, we'll convert it to a `data.frame`.\n\n```{r, cache=TRUE}\ncdf_df <- expand.grid(lat_range, lon_range)\nnames(cdf_df) <- c(\"lat\", \"lon\")\ncdf_df$sst <- NA\nhead(cdf_df)\n```\n\nNow each row of `cdf_df` will correspond to one SST value, one row for every grid cell combination (25 in total). Let's populate it with SST values:\n\n```{r}\nfor(i in 1:nrow(cdf_df))\n{\n  lat_ind <- which(lat == cdf_df[i,\"lat\"])\n  lon_ind <- which(lon == cdf_df[i,\"lon\"])\n  \n  cdf_df[i,\"sst\"] <- sst[lon_ind, lat_ind, time_indices]\n}\n\nhead(cdf_df)\n```\n\nLooks good! Let's make a map to display these data on. Luckily, this is pretty straightforward in R using the `maps` and `mapdata` packages.\n\n```{r firstmap}\nlibrary(maps)\nlibrary(mapdata)\nmap('world2Hires', xlim=range(lon_range) + c(-10, 10), ylim=range(lat_range) + c(-5, 5))\nbox()\npoints(cdf_df$lon, cdf_df$lat)\n```\n\nThe above map is a good start. I've used the `world2Hires` map from `mapdata` which lets me create a map centered on the Eastern Bering Sea. I've specific the x- and y-limits to show just the area where we have SST values. Let's change the points to rectangles and make the background color of the rectangles correlate with the corresponding SST value for that grid.\n\nWe'll first make the color scale:\n\n```{r}\nncolors <- 5\ncols <- cut(cdf_df$sst, ncolors)\npalette <- colorRampPalette((c(\"blue\", \"red\")))(ncolors)\n```\n\nTo plot rectangles instead of points, we can use the rect() function instead of `points()`. `rect()` draws rectangles on the graphics device and needs the user to specify the coordinates of each corner (xleft, ybottom, xright, ytop).\n\n```{r finalmap}\nmap('world2Hires', xlim=range(lon_range) + c(-10, 10), ylim=range(lat_range) + c(-5, 5))\nbox()\n\ngrid_hw <- 0.5 # Grid half width\nrect(cdf_df$lon - grid_hw, cdf_df$lat - grid_hw, cdf_df$lon + grid_hw, cdf_df$lat + grid_hw, col=palette[cols])\n\nmap.axes()\ntitle(main=\"June SST Values\", xlab=\"Longitude\", ylab=\"Lattitude\")\nlegend(\"topright\", legend=levels(cols), fill=palette)\n```\n\nLooks great! Hopefully this post was a useful introduction to working with and displaying NetCDF data.",
    "created" : 1413700366108.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "72151439",
    "id" : "E94B21CF",
    "lastKnownWriteTime" : 1413700463,
    "path" : "~/src/amoeba.github.io/_rmd/2014-02-18-working-with-netcdf-files-in-r.Rmd",
    "project_path" : "_rmd/2014-02-18-working-with-netcdf-files-in-r.Rmd",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}